Un _render prop_ es una t√©cnica para **compartir l√≥gica** (estado, efectos, comportamientos) entre componentes sin acoplar la UI.

**¬øCu√°l es su funci√≥n especial dentro de React?**  
Permite que un componente ‚Äúgen√©rico‚Äù delegue la parte de **renderizado** a quien lo use, pasando datos y callbacks a una funci√≥n, y dejando que esa funci√≥n devuelva el TSX concreto.

## Ejemplo con Render Props

**Ejemplo**
```
src/
‚îú‚îÄ components/
‚îÇ  ‚îú‚îÄ Wrapper.tsx
‚îÇ  ‚îú‚îÄ Counter1.tsx
‚îÇ  ‚îî‚îÄ Counter2.tsx
‚îî‚îÄ App.tsx
```

En simples palabras lo que sucede aqu√≠ es que usamos una clase para definir el funcionamiento de un componente, literalmente lo cargamos con la log√≠ca.
```tsx
// components/Wrapper.tsx
import React from "react";

//
// Definimos la forma de los datos que pasaremos al render prop.
//
interface WrapperRenderProps {
  count: number;
  incCount: () => void;
}

//
// Props que recibe nuestro Wrapper: una sola prop ‚Äúrender‚Äù
// que es una funci√≥n que recibe { count, incCount } y devuelve JSX.
//
interface WrapperProps {
  render: (props: WrapperRenderProps) => React.ReactNode;
}

interface WrapperState {
  count: number;
}

export class Wrapper extends React.Component<WrapperProps, WrapperState> {
  state: WrapperState = { count: 0 };

  // M√©todo para incrementar el contador
  incCount = () => {
    this.setState((prev) => ({ count: prev.count + 1 }));
  };

  render() {
    // Llamamos a this.props.render y le pasamos { count, incCount } 
    return (
      <>
        {this.props.render({
          count: this.state.count,
          incCount: this.incCount,
        })}
      </>
    );
  }
}
```

Los componentes solo contendr√°n la "cascara" de la l√≥gica que se les implementara.  
```tsx
// components/Counter1.tsx
import React from "react";

// Props que recibe Counter1
interface Counter1Props {
  count: number;
  incCount: () => void;
}

export const Counter1: React.FC<Counter1Props> = ({ count, incCount }) => {
  return (
    <div>
      <p>Counter1: {count}</p>
      <button onClick={incCount}>Incrementar Counter1</button>
    </div>
  );
};

```

```tsx
// components/Counter2.tsx
import React from "react";

// Props que recibe Counter2
interface Counter2Props {
  count: number;
  incCount: () => void;
}

export const Counter2: React.FC<Counter2Props> = ({ count, incCount }) => {
  return (
    <div>
      <p style={{ color: "purple" }}>Counter2: {count}</p>
      <button style={{ color: "purple" }} onClick={incCount}>
        Incrementar Counter2
      </button>
    </div>
  );
};

```

La l√≥gica es implementada dentro del **Objeto** wrapper 
```tsx
// App.tsx
import React from "react";
import { Wrapper } from "./components/Wrapper";
import { Counter1 } from "./components/Counter1";
import { Counter2 } from "./components/Counter2";

export const App: React.FC = () => {
  return (
    <div style={{ padding: 20 }}>
      {/* Primer Wrapper: render prop que renderiza Counter1 */}
      <Wrapper
        render={({ count, incCount }) => {
          return <Counter1 count={count} incCount={incCount} />;
        }}
      />

      {/* Segundo Wrapper: render prop que renderiza Counter2 */}
      <Wrapper
        render={({ count, incCount }) => {
          return <Counter2 count={count} incCount={incCount} />;
        }}
      />
    </div>
  );
};

```

**Verboso / Boilerplate**
- Hay que definir por fuerza interfaces (`WrapperProps`, `WrapperState`, `WrapperRenderProps`) y anidar la llamada a `this.props.render(...)` dentro de _render()_.
- Cada vez que consumas el componente `Wrapper`, debes escribir `<Wrapper render={ props => (‚Ä¶) } />`, lo cual puede volverse tedioso.

**Anidamiento de JSX (‚ÄúCallback Hell‚Äù)**
- Si en lugar de un solo render prop tuvieras varios (por ejemplo, un `AuthProvider` que tambi√©n use render props, luego un `DataProvider`, etc.), terminar√≠as con varias capas de anidaci√≥n
```tsx
<AuthProvider render={(user) => (
  <DataProvider render={(data) => (
    <Wrapper render={({ count, incCount }) => (
      <App data={data} user={user} count={count} incCount={incCount} />
    )} />
  )} />
)} />

```
## Ejemplo con custom hooks
A partir de React 16.8+, la forma m√°s sencilla de compartir l√≥gica de estado y efectos es usando **Hooks personalizados**. Vamos a reescribir el mismo ejemplo (dos contadores independientes) sin Render Props ni componentes de clase, usando s√≥lo funciones y Hooks.


```
src/
‚îú‚îÄ hooks/
‚îÇ  ‚îî‚îÄ useCounter.ts
‚îú‚îÄ components/
‚îÇ  ‚îú‚îÄ Counter1.tsx
‚îÇ  ‚îú‚îÄ Counter2.tsx
‚îÇ  ‚îî‚îÄ CounterDisplay.tsx
‚îî‚îÄ App.tsx
```

```tsx
// hooks/useCounter.ts
import { useState, useCallback } from "react";

interface UseCounterReturn {
  count: number;
  incCount: () => void;
}

export function useCounter(initial: number = 0): UseCounterReturn {
  const [count, setCount] = useState<number>(initial);

  // useCallback para memorizar la funci√≥n y evitar re-creaciones innecesarias.
  const incCount = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []);

  return { count, incCount };
}
```

`useCounter` es un Hook personalizado que expone `{ count, incCount }`.

Internamente usa `useState` para el contador y `useCallback` para memorizar la funci√≥n de incremento (no esencial, pero recomendado en casos reales).

```tsx
// components/CounterDisplay.tsx
import React from "react";

export interface CounterDisplayProps {
  label: string;
  count: number;
  incCount: () => void;
  color?: string;
}

export const CounterDisplay: React.FC<CounterDisplayProps> = ({
  label,
  count,
  incCount,
  color = "black",
}) => {
  return (
    <div style={{ marginBottom: 16 }}>
      <p style={{ color }}>
        {label}: {count}
      </p>
      <button style={{ color }} onClick={incCount}>
        Incrementar {label}
      </button>
    </div>
  );
};
```

`CounterDisplay` es un componente puramente de presentaci√≥n (presentation-only).   Recibe:
- `label` (cadena que identifica el contador),
- `count` (n√∫mero),
- `incCount` (funci√≥n para incrementar),
- `color` (opcional, para cambiar estilo).

No gestiona ning√∫n estado propio; s√≥lo pinta lo que le pasan por props.

`components/Counter1.tsx`
```tsx
// components/Counter1.tsx
import React from "react";
import { useCounter } from "../hooks/useCounter";
import { CounterDisplay } from "./CounterDisplay";

export const Counter1: React.FC = () => {
  const { count, incCount } = useCounter(0);

  return <CounterDisplay label="Counter1" count={count} incCount={incCount} />;
};

```

`components/Counter2.tsx`
```tsx
// components/Counter2.tsx
import React from "react";
import { useCounter } from "../hooks/useCounter";
import { CounterDisplay } from "./CounterDisplay";

export const Counter2: React.FC = () => {
  const { count, incCount } = useCounter(0);

  // Aqu√≠ cambias el color a p√∫rpura para diferenciarlo
  return (
    <CounterDisplay
      label="Counter2"
      count={count}
      incCount={incCount}
      color="purple"
    />
  );
};

```

`App.tsx`
```tsx
// App.tsx
import React from "react";
import { Counter1 } from "./components/Counter1";
import { Counter2 } from "./components/Counter2";

export const App: React.FC = () => {
  return (
    <div style={{ padding: 20 }}>
      <Counter1 />
      <Counter2 />
    </div>
  );
};

```

### Ventajas de usar los custom hooks
**Simplicidad y Concisi√≥n**
- No necesitas definir clases, constructores ni estados en forma de `this.state`.
- El Hook `useCounter` encapsula la l√≥gica de estado y `useCallback`. Queda todo en pocas l√≠neas.
**Separaci√≥n L√≥gica / UI**
- El Hook (`useCounter`) se encarga _√∫nicamente_ de la parte de estado.
- `CounterDisplay` ‚Äîel componente de presentaci√≥n‚Äî s√≥lo muestra los datos que recibe.
- Si en otro componente necesitas un contador, basta con importar `useCounter(‚Ä¶)` y pasarlo a cualquier componente que cumpla la UI (no tienes que replicar un ‚ÄúWrapper‚Äù con render props).
**Tipado m√°s Natural**
- `useCounter` retorna una tupla u objeto con el estado. No hace falta definir una interfaz para el ‚Äúrender prop‚Äù.
- Los componentes funcionales usan `React.FC<‚Ä¶>` y definen directamente sus props. Esto tiende a ser menos verboso que declarar `WrapperProps`, `WrapperState`, etc.

#### Evitar callback-hell
- Con render props, cada proveedor enlazado ten√≠a su propio `<Componente render={‚Ä¶} />`. Con Hooks, s√≥lo importas `useCounter` o el custom Hook que necesites y lo consumes inline (sin anidar JSX)
- El flujo de datos es m√°s plano y m√°s f√°cil de leer.

#### Comparaci√≥n

| Caracter√≠stica       | Render Props (clase/funci√≥n)                                                                                                     | Hooks + Funcionales                                                                                                         |
| -------------------- | -------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| Verbosidad           | üî¥ Hay que definir interfaces de props, estado y render prop.                                                                    | üü¢ Hook + componentes puros, mucho m√°s conciso.                                                                             |
| Anidamiento          | üî¥ Si combinas varios render props o HOCs, terminas con ‚ÄúJSX hell‚Äù.                                                              | üü¢ Se usa el Hook directamente, sin anidamientos complejos.                                                                 |
| Separaci√≥n l√≥gica/UI | üî¥ Se ‚Äúrompe‚Äù el flujo: l√≥gica en Wrapper (clase), UI en el callback.                                                            | üü¢ L√≥gica en el Hook, UI en componentes separados o inline.                                                                 |
| Tipado TSX           | üî¥ Tienes que definir manualmente varios `interface` / `type`.                                                                   | üü¢ S√≥lo defines tipos de las props de cada componente y de los retornos del Hook.                                           |
| Mantenimiento        | üî¥ Si quieres cambiar algo en la l√≥gica (p. ej. agregar `isLoading`), tienes que modificar Wrapper y la firma de la render prop. | üü¢ Cambio en el Hook, los componentes de UI s√≥lo reciben nuevas props, casi transparente.                                   |
| Curva de aprendizaje | üü† Si vienes de POO, puede resultar familiar, pero `this` y `componentDidMount` confunden a algunos.                             | üü¢ Hooks tienen una curva de ‚Äúaprender bien las reglas‚Äù (dependencies, etc.), pero una vez entendidos, todo es m√°s directo. |
| Compatibilidad       | üî¥ Basado en clases o funciones antiguas; ya no es ‚Äúla forma preferida‚Äù en React moderno.                                        | üü¢ Patr√≥n actual; fomentado por la documentaci√≥n oficial de React 17/18.                                                    |
